import numpy as np
import matplotlib.pyplot as plt

# 그래프 스타일을 시각적으로 깔끔한 ggplot 스타일로 설정
plt.style.use('ggplot')

def simulate_genetic_drift(N, p0, generations, trajectories):
    """
    라이트-피셔 모델 시뮬레이션 함수
    """
    history = np.zeros((trajectories, generations + 1))
    history[:, 0] = p0

    for t in range(trajectories):
        current_p = p0
        for g in range(1, generations + 1):
            # 이항 분포를 이용한 무작위 추출 (2N: 전체 유전자 수)
            k = np.random.binomial(2 * N, current_p)
            current_p = k / (2 * N)
            history[t, g] = current_p
            
            # 유전자가 고정되거나 소실되면 루프 종료
            if current_p == 0 or current_p == 1:
                history[t, g:] = current_p
                break
    return history

# --- 시뮬레이션 설정 ---
N_list = [50, 100, 1000, 5000]  # 집단 크기
p_list = [0.1, 0.5, 0.8]        # 초기 빈도
gens = 100                      # 관찰 세대
trials = 50                     # 시각화할 선의 개수 (궤적)
v_samples = 10000               # 분산 검증을 위한 샘플 수

fig, axes = plt.subplots(len(N_list), len(p_list), figsize=(15, 12), sharex=True, sharey=True)
plt.subplots_adjust(hspace=0.4, wspace=0.2)

print(f"{'Condition':<18} | {'Theoretical Var':<15} | {'Actual Var':<15} | {'Error (%)':<10}")
print("-" * 75)

for i, N in enumerate(N_list):
    for j, p in enumerate(p_list):
        # 1. 시뮬레이션 데이터 생성 (그래프용)
        data = simulate_genetic_drift(N, p, gens, trials)
        
        # 2. 그래프 시각화
        ax = axes[i, j]
        for t in range(trials):
            # 투명도(alpha)와 얇은 선(lw)을 이용해 밀도 표현
            ax.plot(data[t], lw=0.7, color='black', alpha=0.4)
        
        ax.set_ylim(-0.05, 1.05)
        if i == 0: ax.set_title(f"Initial p = {p}", fontsize=12)
        if j == 0: ax.set_ylabel(f"N = {N}\nFreq(p)", fontsize=12)
        
        # 3. 분산 검증 (모든 조건에서 수행)
        # 이론적 분산 공식: Var = p(1-p) / 2N
        theoretical_var = (p * (1 - p)) / (2 * N)
        
        # 실제 분산 측정 (10,000번 반복 시행 후 1세대 뒤의 빈도 분포 확인)
        p_next_gen = np.random.binomial(2 * N, p, v_samples) / (2 * N)
        actual_var = np.var(p_next_gen)
        
        # 오차율 계산
        error_pct = abs(theoretical_var - actual_var) / theoretical_var * 100
        
        # 모든 N과 p에 대한 결과 출력
        cond_str = f"N={N}, p={p}"
        print(f"{cond_str:<18} | {theoretical_var:15.8f} | {actual_var:15.8f} | {error_pct:9.2f}%")

plt.suptitle("Genetic Drift Analysis", fontsize=16, y=0.95)
plt.show()